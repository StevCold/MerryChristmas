{"ast":null,"code":"import { Vector3 } from \"three\";\nclass STLExporter {\n  parse(scene, options = {}) {\n    options = Object.assign({\n      binary: false\n    }, options);\n    const binary = options.binary;\n    const objects = [];\n    let triangles = 0;\n    scene.traverse(function (object) {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        const index = geometry.index;\n        const positionAttribute = geometry.getAttribute(\"position\");\n        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n        objects.push({\n          object3d: object,\n          geometry\n        });\n      }\n    });\n    let output;\n    let offset = 80;\n    if (binary === true) {\n      const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      output = new DataView(arrayBuffer);\n      output.setUint32(offset, triangles, true);\n      offset += 4;\n    } else {\n      output = \"\";\n      output += \"solid exported\\n\";\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const cb = new Vector3();\n    const ab = new Vector3();\n    const normal = new Vector3();\n    for (let i = 0, il = objects.length; i < il; i++) {\n      const object = objects[i].object3d;\n      const geometry = objects[i].geometry;\n      const index = geometry.index;\n      const positionAttribute = geometry.getAttribute(\"position\");\n      if (index !== null) {\n        for (let j = 0; j < index.count; j += 3) {\n          const a = index.getX(j + 0);\n          const b = index.getX(j + 1);\n          const c = index.getX(j + 2);\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      } else {\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          const a = j + 0;\n          const b = j + 1;\n          const c = j + 2;\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      }\n    }\n    if (binary === false) {\n      output += \"endsolid exported\\n\";\n    }\n    return output;\n    function writeFace(a, b, c, positionAttribute, object) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n      if (object.isSkinnedMesh === true) {\n        object.applyBoneTransform(a, vA);\n        object.applyBoneTransform(b, vB);\n        object.applyBoneTransform(c, vC);\n      }\n      vA.applyMatrix4(object.matrixWorld);\n      vB.applyMatrix4(object.matrixWorld);\n      vC.applyMatrix4(object.matrixWorld);\n      writeNormal(vA, vB, vC);\n      writeVertex(vA);\n      writeVertex(vB);\n      writeVertex(vC);\n      if (binary === true) {\n        output.setUint16(offset, 0, true);\n        offset += 2;\n      } else {\n        output += \"\t\tendloop\\n\";\n        output += \"\tendfacet\\n\";\n      }\n    }\n    function writeNormal(vA2, vB2, vC2) {\n      cb.subVectors(vC2, vB2);\n      ab.subVectors(vA2, vB2);\n      cb.cross(ab).normalize();\n      normal.copy(cb).normalize();\n      if (binary === true) {\n        output.setFloat32(offset, normal.x, true);\n        offset += 4;\n        output.setFloat32(offset, normal.y, true);\n        offset += 4;\n        output.setFloat32(offset, normal.z, true);\n        offset += 4;\n      } else {\n        output += \"\tfacet normal \" + normal.x + \" \" + normal.y + \" \" + normal.z + \"\\n\";\n        output += \"\t\touter loop\\n\";\n      }\n    }\n    function writeVertex(vertex) {\n      if (binary === true) {\n        output.setFloat32(offset, vertex.x, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.y, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.z, true);\n        offset += 4;\n      } else {\n        output += \"\t\t\tvertex \" + vertex.x + \" \" + vertex.y + \" \" + vertex.z + \"\\n\";\n      }\n    }\n  }\n}\nexport { STLExporter };\n//# sourceMappingURL=STLExporter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}