{"ast":null,"code":"import { jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useMemo } from \"react\";\nimport { Uniform, Texture, Color, CanvasTexture, RepeatWrapping, NearestFilter } from \"three\";\nimport { Effect } from \"postprocessing\";\nconst fragment = `\nuniform sampler2D uCharacters;\nuniform float uCharactersCount;\nuniform float uCellSize;\nuniform bool uInvert;\nuniform vec3 uColor;\n\nconst vec2 SIZE = vec2(16.);\n\nvec3 greyscale(vec3 color, float strength) {\n    float g = dot(color, vec3(0.299, 0.587, 0.114));\n    return mix(color, vec3(g), strength);\n}\n\nvec3 greyscale(vec3 color) {\n    return greyscale(color, 1.0);\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    vec2 cell = resolution / uCellSize;\n    vec2 grid = 1.0 / cell;\n    vec2 pixelizedUV = grid * (0.5 + floor(uv / grid));\n    vec4 pixelized = texture2D(inputBuffer, pixelizedUV);\n    float greyscaled = greyscale(pixelized.rgb).r;\n\n    if (uInvert) {\n        greyscaled = 1.0 - greyscaled;\n    }\n\n    float characterIndex = floor((uCharactersCount - 1.0) * greyscaled);\n    vec2 characterPosition = vec2(mod(characterIndex, SIZE.x), floor(characterIndex / SIZE.y));\n    vec2 offset = vec2(characterPosition.x, -characterPosition.y) / SIZE;\n    vec2 charUV = mod(uv * (cell / SIZE), 1.0 / SIZE) - vec2(0., 1.0 / SIZE) + offset;\n    vec4 asciiCharacter = texture2D(uCharacters, charUV);\n\n    asciiCharacter.rgb = uColor * asciiCharacter.r;\n    asciiCharacter.a = pixelized.a;\n    outputColor = asciiCharacter;\n}\n`;\nclass ASCIIEffect extends Effect {\n  constructor({\n    font = \"arial\",\n    characters = ` .:,'-^=*+?!|0#X%WM@`,\n    fontSize = 54,\n    cellSize = 16,\n    color = \"#ffffff\",\n    invert = false\n  } = {}) {\n    const uniforms = /* @__PURE__ */new Map([[\"uCharacters\", new Uniform(new Texture())], [\"uCellSize\", new Uniform(cellSize)], [\"uCharactersCount\", new Uniform(characters.length)], [\"uColor\", new Uniform(new Color(color))], [\"uInvert\", new Uniform(invert)]]);\n    super(\"ASCIIEffect\", fragment, {\n      uniforms\n    });\n    const charactersTextureUniform = this.uniforms.get(\"uCharacters\");\n    if (charactersTextureUniform) {\n      charactersTextureUniform.value = this.createCharactersTexture(characters, font, fontSize);\n    }\n  }\n  /** Draws the characters on a Canvas and returns a texture */\n  createCharactersTexture(characters, font, fontSize) {\n    const canvas = document.createElement(\"canvas\");\n    const SIZE = 1024;\n    const MAX_PER_ROW = 16;\n    const CELL = SIZE / MAX_PER_ROW;\n    canvas.width = canvas.height = SIZE;\n    const texture = new CanvasTexture(canvas, void 0, RepeatWrapping, RepeatWrapping, NearestFilter, NearestFilter);\n    const context = canvas.getContext(\"2d\");\n    if (!context) {\n      throw new Error(\"Context not available\");\n    }\n    context.clearRect(0, 0, SIZE, SIZE);\n    context.font = `${fontSize}px ${font}`;\n    context.textAlign = \"center\";\n    context.textBaseline = \"middle\";\n    context.fillStyle = \"#fff\";\n    for (let i = 0; i < characters.length; i++) {\n      const char = characters[i];\n      const x = i % MAX_PER_ROW;\n      const y = Math.floor(i / MAX_PER_ROW);\n      context.fillText(char, x * CELL + CELL / 2, y * CELL + CELL / 2);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nconst ASCII = forwardRef(({\n  font = \"arial\",\n  characters = ` .:,'-^=*+?!|0#X%WM@`,\n  fontSize = 54,\n  cellSize = 16,\n  color = \"#ffffff\",\n  invert = false\n}, fref) => {\n  const effect = useMemo(() => new ASCIIEffect({\n    characters,\n    font,\n    fontSize,\n    cellSize,\n    color,\n    invert\n  }), [characters, fontSize, cellSize, color, invert, font]);\n  return /* @__PURE__ */jsx(\"primitive\", {\n    ref: fref,\n    object: effect\n  });\n});\nexport { ASCII };\n//# sourceMappingURL=ASCII.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}