{"ast":null,"code":"import { jsx } from \"react/jsx-runtime\";\nimport { HalfFloatType } from \"three\";\nimport React, { createContext, forwardRef, useMemo, useEffect, useRef, useLayoutEffect, useImperativeHandle } from \"react\";\nimport { useThree, useFrame, useInstanceHandle } from \"@react-three/fiber\";\nimport { EffectComposer as EffectComposer$1, RenderPass, NormalPass, DepthDownsamplingPass, Effect, EffectPass, EffectAttribute, Pass } from \"postprocessing\";\nimport { isWebGL2Available } from \"three-stdlib\";\nconst EffectComposerContext = createContext(null);\nconst isConvolution = effect => (effect.getAttributes() & EffectAttribute.CONVOLUTION) === EffectAttribute.CONVOLUTION;\nconst EffectComposer = React.memo(forwardRef(({\n  children,\n  camera: _camera,\n  scene: _scene,\n  resolutionScale,\n  enabled = true,\n  renderPriority = 1,\n  autoClear = true,\n  depthBuffer,\n  disableNormalPass,\n  stencilBuffer,\n  multisampling = 8,\n  frameBufferType = HalfFloatType\n}, ref) => {\n  const {\n    gl,\n    scene: defaultScene,\n    camera: defaultCamera,\n    size\n  } = useThree();\n  const scene = _scene || defaultScene;\n  const camera = _camera || defaultCamera;\n  const [composer, normalPass, downSamplingPass] = useMemo(() => {\n    const webGL2Available = isWebGL2Available();\n    const effectComposer = new EffectComposer$1(gl, {\n      depthBuffer,\n      stencilBuffer,\n      multisampling: multisampling > 0 && webGL2Available ? multisampling : 0,\n      frameBufferType\n    });\n    effectComposer.addPass(new RenderPass(scene, camera));\n    let downSamplingPass2 = null;\n    let normalPass2 = null;\n    if (!disableNormalPass) {\n      normalPass2 = new NormalPass(scene, camera);\n      normalPass2.enabled = false;\n      effectComposer.addPass(normalPass2);\n      if (resolutionScale !== void 0 && webGL2Available) {\n        downSamplingPass2 = new DepthDownsamplingPass({\n          normalBuffer: normalPass2.texture,\n          resolutionScale\n        });\n        downSamplingPass2.enabled = false;\n        effectComposer.addPass(downSamplingPass2);\n      }\n    }\n    return [effectComposer, normalPass2, downSamplingPass2];\n  }, [camera, gl, depthBuffer, stencilBuffer, multisampling, frameBufferType, scene, disableNormalPass, resolutionScale]);\n  useEffect(() => composer == null ? void 0 : composer.setSize(size.width, size.height), [composer, size]);\n  useFrame((_, delta) => {\n    if (enabled) {\n      const currentAutoClear = gl.autoClear;\n      gl.autoClear = autoClear;\n      if (stencilBuffer && !autoClear) gl.clearStencil();\n      composer.render(delta);\n      gl.autoClear = currentAutoClear;\n    }\n  }, enabled ? renderPriority : 0);\n  const group = useRef(null);\n  const instance = useInstanceHandle(group);\n  useLayoutEffect(() => {\n    const passes = [];\n    if (group.current && instance.current && composer) {\n      const children2 = instance.current.objects;\n      for (let i = 0; i < children2.length; i++) {\n        const child = children2[i];\n        if (child instanceof Effect) {\n          const effects = [child];\n          if (!isConvolution(child)) {\n            let next = null;\n            while ((next = children2[i + 1]) instanceof Effect) {\n              if (isConvolution(next)) break;\n              effects.push(next);\n              i++;\n            }\n          }\n          const pass = new EffectPass(camera, ...effects);\n          passes.push(pass);\n        } else if (child instanceof Pass) {\n          passes.push(child);\n        }\n      }\n      for (const pass of passes) composer == null ? void 0 : composer.addPass(pass);\n      if (normalPass) normalPass.enabled = true;\n      if (downSamplingPass) downSamplingPass.enabled = true;\n    }\n    return () => {\n      for (const pass of passes) composer == null ? void 0 : composer.removePass(pass);\n      if (normalPass) normalPass.enabled = false;\n      if (downSamplingPass) downSamplingPass.enabled = false;\n    };\n  }, [composer, children, camera, normalPass, downSamplingPass, instance]);\n  const state = useMemo(() => ({\n    composer,\n    normalPass,\n    downSamplingPass,\n    resolutionScale,\n    camera,\n    scene\n  }), [composer, normalPass, downSamplingPass, resolutionScale, camera, scene]);\n  useImperativeHandle(ref, () => composer, [composer]);\n  return /* @__PURE__ */jsx(EffectComposerContext.Provider, {\n    value: state,\n    children: /* @__PURE__ */jsx(\"group\", {\n      ref: group,\n      children\n    })\n  });\n}));\nexport { EffectComposer, EffectComposerContext };\n//# sourceMappingURL=EffectComposer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}