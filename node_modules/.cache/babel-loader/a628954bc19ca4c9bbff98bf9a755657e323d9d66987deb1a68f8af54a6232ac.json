{"ast":null,"code":"import { jsx } from \"react/jsx-runtime\";\nimport { SelectiveBloomEffect, BlendFunction } from \"postprocessing\";\nimport { forwardRef, useContext, useMemo, useEffect } from \"react\";\nimport { useThree } from \"@react-three/fiber\";\nimport { EffectComposerContext } from \"../EffectComposer.js\";\nimport { selectionContext } from \"../Selection.js\";\nimport { resolveRef } from \"../util.js\";\nconst addLight = (light, effect) => light.layers.enable(effect.selection.layer);\nconst removeLight = (light, effect) => light.layers.disable(effect.selection.layer);\nconst SelectiveBloom = forwardRef(function SelectiveBloom2({\n  selection = [],\n  selectionLayer = 10,\n  lights = [],\n  luminanceThreshold,\n  luminanceSmoothing,\n  intensity,\n  width,\n  height,\n  kernelSize,\n  mipmapBlur,\n  ...props\n}, forwardRef2) {\n  if (lights.length === 0) {\n    console.warn(\"SelectiveBloom requires lights to work.\");\n  }\n  const invalidate = useThree(state => state.invalidate);\n  const {\n    scene,\n    camera\n  } = useContext(EffectComposerContext);\n  const effect = useMemo(() => new SelectiveBloomEffect(scene, camera, {\n    blendFunction: BlendFunction.ADD,\n    luminanceThreshold,\n    luminanceSmoothing,\n    intensity,\n    width,\n    height,\n    kernelSize,\n    mipmapBlur,\n    ...props\n  }), [scene, camera, luminanceThreshold, luminanceSmoothing, intensity, width, height, kernelSize, mipmapBlur, props]);\n  const api = useContext(selectionContext);\n  useEffect(() => {\n    if (!api && selection) {\n      effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);\n      invalidate();\n      return () => {\n        effect.selection.clear();\n        invalidate();\n      };\n    }\n  }, [effect, selection, api, invalidate]);\n  useEffect(() => {\n    effect.selection.layer = selectionLayer;\n    invalidate();\n  }, [effect, invalidate, selectionLayer]);\n  useEffect(() => {\n    if (lights && lights.length > 0) {\n      lights.forEach(light => addLight(resolveRef(light), effect));\n      invalidate();\n      return () => {\n        lights.forEach(light => removeLight(resolveRef(light), effect));\n        invalidate();\n      };\n    }\n  }, [effect, invalidate, lights, selectionLayer]);\n  useEffect(() => {\n    var _a;\n    if (api && api.enabled) {\n      if ((_a = api.selected) == null ? void 0 : _a.length) {\n        effect.selection.set(api.selected);\n        invalidate();\n        return () => {\n          effect.selection.clear();\n          invalidate();\n        };\n      }\n    }\n  }, [api, effect.selection, invalidate]);\n  return /* @__PURE__ */jsx(\"primitive\", {\n    ref: forwardRef2,\n    object: effect,\n    dispose: null\n  });\n});\nexport { SelectiveBloom };\n//# sourceMappingURL=SelectiveBloom.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}