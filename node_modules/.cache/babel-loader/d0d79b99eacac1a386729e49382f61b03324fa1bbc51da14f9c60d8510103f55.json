{"ast":null,"code":"import { Uniform } from \"three\";\nimport { Effect, EffectAttribute, BlendFunction } from \"postprocessing\";\nimport { wrapEffect } from \"../util.js\";\nconst TiltShiftShader = {\n  fragmentShader: `\n\n    // original shader by Evan Wallace\n\n    #define MAX_ITERATIONS 100\n\n    uniform float blur;\n    uniform float taper;\n    uniform vec2 start;\n    uniform vec2 end;\n    uniform vec2 direction;\n    uniform int samples;\n\n    float random(vec3 scale, float seed) {\n        /* use the fragment position for a different seed per-pixel */\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 color = vec4(0.0);\n        float total = 0.0;\n        vec2 startPixel = vec2(start.x * resolution.x, start.y * resolution.y);\n        vec2 endPixel = vec2(end.x * resolution.x, end.y * resolution.y);\n        float f_samples = float(samples);\n        float half_samples = f_samples / 2.0;\n\n        // use screen diagonal to normalize blur radii\n        float maxScreenDistance = distance(vec2(0.0), resolution); // diagonal distance\n        float gradientRadius = taper * (maxScreenDistance);\n        float blurRadius = blur * (maxScreenDistance / 16.0);\n\n        /* randomize the lookup values to hide the fixed number of samples */\n        float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n        vec2 normal = normalize(vec2(startPixel.y - endPixel.y, endPixel.x - startPixel.x));\n        float radius = smoothstep(0.0, 1.0, abs(dot(uv * resolution - startPixel, normal)) / gradientRadius) * blurRadius;\n\n        #pragma unroll_loop_start\n        for (int i = 0; i <= MAX_ITERATIONS; i++) {\n            if (i >= samples) { break; } // return early if over sample count\n            float f_i = float(i);\n            float s_i = -half_samples + f_i;\n            float percent = (s_i + offset - 0.5) / half_samples;\n            float weight = 1.0 - abs(percent);\n            vec4 sample_i = texture2D(inputBuffer, uv + normalize(direction) / resolution * percent * radius);\n            /* switch to pre-multiplied alpha to correctly blur transparent images */\n            sample_i.rgb *= sample_i.a;\n            color += sample_i * weight;\n            total += weight;\n        }\n        #pragma unroll_loop_end\n\n        outputColor = color / total;\n\n        /* switch back from pre-multiplied alpha */\n        outputColor.rgb /= outputColor.a + 0.00001;\n    }\n    `\n};\nclass TiltShiftEffect extends Effect {\n  constructor({\n    blendFunction = BlendFunction.NORMAL,\n    blur = 0.15,\n    // [0, 1], can go beyond 1 for extra\n    taper = 0.5,\n    // [0, 1], can go beyond 1 for extra\n    start = [0.5, 0],\n    // [0,1] percentage x,y of screenspace\n    end = [0.5, 1],\n    // [0,1] percentage x,y of screenspace\n    samples = 10,\n    // number of blur samples\n    direction = [1, 1]\n    // direction of blur\n  } = {}) {\n    super(\"TiltShiftEffect\", TiltShiftShader.fragmentShader, {\n      blendFunction,\n      attributes: EffectAttribute.CONVOLUTION,\n      uniforms: /* @__PURE__ */new Map([[\"blur\", new Uniform(blur)], [\"taper\", new Uniform(taper)], [\"start\", new Uniform(start)], [\"end\", new Uniform(end)], [\"samples\", new Uniform(samples)], [\"direction\", new Uniform(direction)]])\n    });\n  }\n}\nconst TiltShift2 = wrapEffect(TiltShiftEffect, {\n  blendFunction: BlendFunction.NORMAL\n});\nexport { TiltShift2, TiltShiftEffect };\n//# sourceMappingURL=TiltShift2.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}